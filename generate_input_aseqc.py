'''
Generate Input for ASEQC

Generates an input file compatible with ASEQC. 
This script can be used with gene level ASE files generated by ASE pipelines 
such as ASEReadCounter or phASER. 

Author: Kaushik Ram Ganapathy
Date: 2022-11-14
'''

# External Package Dependancies
import os
import argparse
import pandas as pd

# Function Definitions
def generate_input(input_folder, extension, ref_col, alt_col, gene_col, 
    output_folder, style='cohort', cohort_name='aseqc'):

    '''This is a wrapper script to generate input files for ASEQC. It takes a folder of 
    Allele Specific Expression (ASE) files aggregated by genes and generates requisite input 
    files for ASEQC fits.
    '''
    # Read in the ASE files
    ase_files = os.listdir(input_folder)
    ase_files = [os.path.join(input_folder, x) for x in ase_files]
    
    ase_files = [x for x in ase_files if x.endswith(extension)]
    sample_names = [x.split(f'.{extension}')[0] for x in os.listdir(input_folder) if x.endswith(extension)]

    # Read in the ASE files, drop duplicate and "None" gene names and set the index to gene names
    # By default, comment lines will be ignored (beginning with #)

    ase_files = [pd.read_csv(x, sep='\t', comment="#").dropna(subset=[gene_col]).drop_duplicates(subset=[gene_col]).set_index(gene_col) for x in ase_files]

    # Get reference and alternate allele counts
    ase_files = [x[[ref_col, alt_col]].drop_duplicates() for x in ase_files]
    ref_counts = [x[ref_col].to_frame().drop_duplicates() for x in ase_files]
    alt_counts = [x[alt_col].to_frame().drop_duplicates() for x in ase_files]
    

    # Process as a cohort
    if style == 'cohort':

        # Merge samples into a single dataframe

        # Reference Counts
        ref_counts = pd.concat(ref_counts, axis=1)
        ref_counts.columns = sample_names
        ref_counts = ref_counts.reset_index().rename(columns={f'{gene_col}': 'name'})
        ref_counts = ref_counts.dropna()

        # Alternate Counts
        alt_counts = pd.concat(alt_counts, axis=1)
        alt_counts.columns = sample_names
        alt_counts = alt_counts.reset_index().rename(columns={f'{gene_col}': 'name'})
        alt_counts = alt_counts.dropna()

        
        # Check if there are intersecting genes across all samples
        if len(ref_counts) == 0 or len(alt_counts) == 0:
            raise ValueError('No intersecting genes across samples. Please set style to "single"')

        # # Write out the files
        ref_counts.to_csv(f'{output_folder}/{cohort_name}_ref_counts.txt', sep='\t')
        alt_counts.to_csv(f'{output_folder}/{cohort_name}_alt_counts.txt', sep='\t')

        return True

    # Process as a single sample
    elif style == 'single':
        for i in range(len(sample_names)):

            # Split per sample and write out the files for each sample
            sample_ref_counts = ref_counts[i]
            sample_alt_counts = alt_counts[i]

            sample_ref_counts.columns = [sample_names[i]]
            sample_alt_counts.columns = [sample_names[i]]

            sample_ref_counts = sample_ref_counts.reset_index().rename(columns={f'{gene_col}': 'name'})
            sample_alt_counts = sample_alt_counts.reset_index().rename(columns={f'{gene_col}': 'name'})

            # Get intersecting genes
            intersecting_genes = list(set(sample_ref_counts['name']).intersection(set(sample_alt_counts['name'])))
            sample_ref_counts = sample_ref_counts[sample_ref_counts['name'].isin(intersecting_genes)]
            sample_alt_counts = sample_alt_counts[sample_alt_counts['name'].isin(intersecting_genes)]

            # Sort by gene name
            sample_ref_counts = sample_ref_counts.sort_values(by=['name'])
            sample_alt_counts = sample_alt_counts.sort_values(by=['name'])

            # Write out the files
            sample_ref_counts.to_csv(f'{output_folder}/{sample_names[i]}_ref_counts.txt', sep='\t')
            sample_alt_counts.to_csv(f'{output_folder}/{sample_names[i]}_alt_counts.txt', sep='\t')

        return True

# Main Function for Script
if __name__ == "__main__":

    # Set up the argument parser
    parser = argparse.ArgumentParser(description='Generate input files for ASEQC')
    parser.add_argument('--input_folder', type=str, help='Folder containing ASE files')
    parser.add_argument('--extension', type=str, help='Extension of ASE files')
    parser.add_argument('--ref_col', type=str, help='Name of reference allele count column')
    parser.add_argument('--alt_col', type=str, help='Name of alternate allele count column')
    parser.add_argument('--gene_col', type=str, help='Name of gene column')
    parser.add_argument('--output_folder', type=str, help='Folder to write output files')
    parser.add_argument('--style', type=str, help='Style of input files. Either cohort or single')
    parser.add_argument('--cohort_name', type=str, help='Name of cohort')

    # Parse the arguments
    args = parser.parse_args()

    # Run the function
    generate_input(args.input_folder, args.extension, args.ref_col, args.alt_col, args.gene_col, 
        args.output_folder, args.style, args.cohort_name)







